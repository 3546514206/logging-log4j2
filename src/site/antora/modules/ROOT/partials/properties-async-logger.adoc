.System Properties to configure all asynchronous loggers
[cols="1,1,5"]
|===
h| Java Property

(Environment Variable)
h| Default Value
h| Description

| [[log4j2.asyncLoggerExceptionHandler]]`log4j2.asyncLogger{zwsp}ExceptionHandler`

(`LOG4J_ASYNC_LOGGER_{zwsp}EXCEPTION_HANDLER`)
| link:../javadoc/log4j-core/org/apache/logging/log4j/core/async/AsyncLoggerDefaultExceptionHandler[AsyncLogger{zwsp}DefaultExceptionHandler]
|
Fully qualified name of a class that implements the https://lmax-exchange.github.io/disruptor/javadoc/com.lmax.disruptor/com/lmax/disruptor/ExceptionHandler.html[ExceptionHandler] interface, which will be notified when an exception occurs while logging messages.
The class needs to have a public zero-argument constructor.

The default exception handler will print a message and
stack trace to the standard error output stream.

| [[log4j2.asyncLoggerRingBufferSize]]`log4j2.asyncLogger{zwsp}RingBufferSize`

(`LOG4J_ASYNC_LOGGER_{zwsp}RING_BUFFER_SIZE`)
| `256 &times; 1024`

`4 &times; 1024` (GC mode)
|
Size (number of slots) in the RingBuffer used by the asynchronous
logging subsystem.
Make this value large enough to deal with bursts of
activity.
The minimum size is 128.
The RingBuffer will be pre-allocated at first use and will never grow or shrink during the life of the system.

When the application is logging faster than the underlying appender can keep up with for a long enough time to fill
up the queue, the behaviour is determined by the link:../javadoc/log4j-core/org/apache/logging/log4j/core/async/AsyncQueueFullPolicy.html[AsyncQueueFullPolicy].

| [[log4j2.asyncLoggerWaitStrategy]]`log4j2.asyncLogger{zwsp}WaitStrategy`

(`LOG4J_ASYNC_LOGGER_{zwsp}WAIT_STRATEGY`)
| `Timeout`
a| Specifies the https://lmax-exchange.github.io/disruptor/javadoc/com.lmax.disruptor/com/lmax/disruptor/WaitStrategy.html[WaitStrategy] used by the LMAX Disruptor.

Valid values:

* `Block`: a strategy that uses a lock and condition variable for the I/O thread waiting for log events.
Block can be used when throughput and low-latency are not as important as CPU resource.
Recommended for resource constrained/virtualised environments.

* `Timeout`: a variation of the `Block` strategy that will periodically wake up from the lock condition `await()` call.
This ensures that if a notification is missed somehow the consumer thread is not stuck but will recover with a small latency delay (see <<log4j2.asyncLoggerTimeout>>)

* `Sleep`: a strategy that initially spins, then uses a `Thread.yield()`, and eventually parks for the minimum number of nanos the OS and JVM will allow while the I/O thread is waiting for log events (see <<log4j2.asyncLoggerRetries>> and <<log4j2.asyncLoggerSleepTimeNs>>).
Sleep is a good compromise between performance and CPU resource.
This strategy has very low impact on the application thread, in exchange for some additional latency for actually getting the message logged.

* `Yield`: is a strategy that uses a `Thread.yield()` for waiting for log events after an initially spinning.
Yield is a good compromise between performance and CPU resource, but may use more CPU than `Sleep` in order to get the message logged to disk sooner.

* a <<Custom WaitStrategy>>.

|[[log4j2.asyncLoggerTimeout]]`log4j2.asyncLogger{zwsp}Timeout`

(`LOG4J_ASYNC_LOGGER_{zwsp}TIMEOUT`)
|`10`
|Timeout in milliseconds of `Timeout` wait strategy (see <<log4j2.asyncLoggerWaitStrategy>>).

| [[log4j2.asyncLoggerSleepTimeNs]]`log4j2.asyncLogger{zwsp}SleepTimeNs`

(`LOG4J_ASYNC_LOGGER_{zwsp}SLEEP_TIME_NS`)
| `100`
| Sleep time in nanoseconds of `Sleep` wait strategy (see <<log4j2.asyncLoggerWaitStrategy>>).

| [[log4j2.asyncLoggerRetries]]`log4j2.asyncLogger{zwsp}Retries`

(`LOG4J_ASYNC_LOGGER_{zwsp}RETRIES`)
| `200`
| Total number of spin cycles and `Thread.yield()` cycles of `Sleep` (see <<log4j2.asyncLoggerWaitStrategy>>).

| [[log4j2.asyncLoggerSynchronizeEnqueueWhenQueueFull]]`log4j2.asyncLogger{zwsp}SynchronizeEnqueueWhenQueueFull`

(`LOG4J_ASYNC_LOGGER_{zwsp}SYNCHRONIZE_ENQUEUE_WHEN_QUEUE_FULL`)
| `true`
|Synchronizes access to the Disruptor ring buffer for blocking enqueue operations when the queue is full.
Users encountered excessive CPU utilization with Disruptor v3.4.2 when the application was logging more than the underlying appender could keep up with and the ring buffer became full, especially when the number of application threads vastly outnumbered the number of cores.
CPU utilization is significantly reduced by restricting access to the enqueue operation.
Setting this value to `false` may lead to very high CPU utilization when the async logging queue is full.

| [[log4j2.asyncLoggerThreadNameStrategy]]`log4j2.asyncLogger{zwsp}ThreadNameStrategy`

(`LOG4J_ASYNC_LOGGER_{zwsp}HREAD_NAME_STRATEGY`)
| `UNCACHED` for JRE 8u102 or later, `CACHED` otherwise
| Specifies the link:../javadoc/log4j-core/org/apache/logging/log4j/core/async/ThreadNameCachingStrategy to use to cache the result of https://docs.oracle.com/javase/{java-target-version}/docs/api/java/lang/Thread.html#getName()[Thread.getName()].

This setting allows to cache the result of `Thread.getName()` calls:

* a value of `CACHED` stores the name of the current thread in a `ThreadLocal` field,
* a value of `UNCACHED` disable caching.

**Remark**: Since JRE 8u102 the `Thread.getName()` method does not allocate a new object.

|===
////
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
////
[id=configuration]
= Configuration
Ralph Goers <rgoers@apache.org>; Piotr Karwasz <pkarwasz@apache.org>

Since logging is a common way to monitor the health of an application and diagnose problems that occur in it, even moderately sized applications can contain thousands of logging statements.

In order to decide which of these statements will be logged and where, users need to configure Log4j Core.

Log4j Core can be configured in two ways:

* through a <<configuration-file>>.
Since version 2.0 the configuration file format is considered as part of the public API, and it remains stable even across major version upgrades.

* through xref:manual/customconfig.adoc[Programmatic Configuration], which provides a larger spectrum of possible customizations, but might require code changes even for minor version upgrades, according to https://semver.org/[semantic versioning] rules.

[NOTE]
====
To prevent a chicken-and-egg problem some configuration options, such as the location of the configuration file can be supplied only through xref:manual/systemproperties.adoc[System properties].
====

[#configuration-file]
== Configuration file

TIP: For a quick example of configuration file see the xref:manual/installation.adoc#impl-core-config[Configuring Log4j Core section].

Log4j Core can be configured using multiple configuration file formats.
Configuration factories for the XML, JSON, YAML and Java properties format are included in the `log4j-core` artifact.

Some configuration formats require additional dependencies to be present on the classpath, according to the table below.

include::partial$configuration-file-format-deps.adoc[]

[WARNING]
====
The format of the configuration file changed between Log4j{nbsp}1 and Log4j{nbsp}2.
Files in the Log4j{nbsp}1 formats are ignored by default.

To enable partial support for old configuration formats see xref:manual/migration.adoc#enabling-the-log4j-1-x-bridge[Enabling the Log4j{nbsp}1 bridge].
====

[id=automatic-configuration]
=== [[AutomaticConfiguration]] Configuration file location

Upon initialization of a new logger context, Log4j assigns it a context name and scans the following **classpath** locations for a configuration file:

. Files named `log4j2-test<contextName>.<extension>`
. Files named `log4j2-test.<extension>`,
. Files named `log4j2<contextName>.<extension>`
. Files named `log4j2.<extension>`,
. If no configuration file could be located a link:../javadoc/log4j-core/org/apache/logging/log4j/core/config/DefaultConfiguration[DefaultConfiguration] is used and a warning is printed by the status logger.
The default configuration prints all messages less specific than
xref:manual/systemproperties.adoc#log4j2.level[log4j2.level]
to the console.

[CAUTION]
====
The configuration files prefixed by `log4j2-test` should only be used on the test classpath.

If multiple configuration files in the same category are found, Log4j uses a deterministic order to choose one of them (cf. link:../javadoc/log4j-core/org/apache/logging/log4j/core/config/Order[@Order]).
Nevertheless, application developers are advised not to use multiple configuration files that differ only by the extension.

Most libraries should not contain Log4j configuration files in their default location to allow applications to define their own.
====

The `<contextName>` and `<extension>` placeholders above have the following meaning

<contextName>:: depends on the runtime environment in which Log4j runs:

* for standalone Java SE application it is a random identifier,
* for web applications it is derived from the application descriptor.
See xref:manual/webapp.adoc#configuration[Log4j
 Web application configuration] for more details.

<extension>:: must be one of the file extensions assigned to a configuration file format:
+
[cols="1,1"]
|===
| Configuration file format | Extension

| XML
| `xml`

| JSON
| `json` or `jsn`

| YAML
| `yaml` or `yml`

|Java properties
| `properties`
|===

[NOTE]
====
It is also possible to override the location of the configuration file using the
xref:manual/systemproperties.adoc#log4j2.configurationFile[log4j2.configurationFile]
configuration property.

In this case Log4j will guess the configuration file format from the extension of the provided configuration file or will use the default configuration factory if the extension is unknown.
See xref:manual/systemproperties.adoc#log4j2.configurationFile[log4j2.configurationFile] for details.
====

[id=configuration-syntax]
=== [[ConfigurationSyntax]] Syntax

All configuration files are parsed into a tree of link:../javadoc/log4j-core/org/apache/logging/log4j/core/config/Node[Node]s, each representing a different Log4j component.
The root of the tree creates a link:../javadoc/log4j-core/org/apache/logging/log4j/core/config/Configuration[Configuration] object.

A node is a fairly simple structure that represents a single Log4j plugin (cf. xref:plugin-reference.adoc[] for a complete list) such as an appender, layout or logger configuration.
Each node has:

* a set of simple string key value pairs called **attributes**.
Attributes are **matched by name** against the list of available configuration options of a Log4j plugin.

* one distinguished attribute called **plugin type** specifies the kind of Log4j plugin we want to instantiate.

* a set of child nodes called **nested elements**.
They are **matched by type** against the list of nested components that a Log4j plugin accepts.

Log4j maps the concepts above to the specifics of the configuration format as follows:

[tabs]
=====
XML::
+
Since XML was the original configuration format developed, the mapping from configuration nodes and XML elements is trivial:
+
[id=configuration-with-xml]
====
* Each configuration node is represented by an XML element.
* Each configuration attribute is represented by an XML attribute.
* The **plugin type** of a node is equal to the name of the XML tag.
* Each configuration nested element is represented by a nested XML element.
====
+
[NOTE]
====
There is an alternative XML configuration format called "XML strict format" that is activated by setting the `strict` attribute of the main `<Configuration>` element to `true`.

It allows users to use arbitrary tag names as long as they provide the plugin type using a `type` property.
It was conceived as a simplified XML format that can be validated by an XML schema.

Nowadays, the automatically generated schemas published at https://logging.apache.org/xml/ns/ offer a better alternative and allow users to use the more concise syntax.
====

JSON::
+
In the JSON configuration format:
+
[id=configuration-with-json]
====
* Each configuration node is represented by a JSON object,
* JSON properties of type string, number or boolean are mapped to node attributes.
* JSON properties of type object or array are used to represent nested configuration elements.
* The **plugin type** of a JSON object is given by:
** the value of the `type` key, if present,
** or the key associated with the JSON object otherwise,
** if the JSON object representing the node is part of an array, the key associated to the JSON array is used.
====
+
[TIP]
====
If you need to specify multiple plugins of the same type, you can use JSON arrays.
The snippet below represents two plugins of type `File`.

[source,json]
----
{
  "File": [
    {
      "name": "file1"
    },
    {
      "name": "file2"
    }
  ]
}
----
====

YAML::
+
In the YAML configuration format:
+
[id=configuration-with-yaml]
====
* Each configuration node is represented by a YAML mapping,
* YAML properties of scalar type are mapped to node attributes.
* YAML properties of collection type are used to represent nested configuration elements.
* The **plugin type** of a YAML mapping is given by:
** the value of the `type` key, if present,
** or the key associated with the YAML mapping otherwise,
** if the YAML mapping representing the node is part of a YAML block sequence, the key associated to the YAML sequence is used.
====
+
[TIP]
====
If you need to specify multiple plugins of the same type, you can use YAML block sequences.
The snippet below represents two plugins of type `File`.

[source,yaml]
----
File:
  - name: file1
  - name: file2
----
====

Java properties::
+
The Java properties format is not well suited to represent hierarchical structures.
In the Java properties configuration format:
+
[id=configuration-with-properties]
====
* Properties that share a common prefix (e.g. `appender.foo`) are mapped to a subtree of the configuration node tree.
* Configuration attributes are specified by appending the name of the property (e.g. `name`) to the prefix of the node, separated by a dot (e.g. `appender.foo.name`).
* The **plugin type** must necessarily be specified as an attribute named `type`.
* Nested elements are created by:
** choosing an arbitrary id for the nested component (e.g. `<0>`),
** appending the id to the prefix of the parent component (e.g. `appender.foo.<0>`),
** specifying the type of the nested plugin by assigning a `type` attribute (e.g. `appender.foo.<0>.type`).
====
+
[NOTE]
====
The id assigned to nested components is only used for sorting purposes.
However, some components assign a special meaning to some ids.
See a list of exceptions in <<java-properties-features>>.
====

=====

[id=main-configuration-elements]
=== Main configuration elements

Log4j Core's logging pipeline is quite complex (see xref:manual/architecture.adoc[Architecture]), but most users only require these elements:

Loggers::
+
Loggers are the entry point of the logging pipeline, directly used in code.
Their configuration must specify which level of messages they log and to which appenders they send the messages.
+
See <<configuring-loggers>> for details.

[id=configuring-appenders]
[[Appenders]] Appenders::
+
Appenders are the exit point of the logging pipeline.
They decide to which resource (console, file, database, etc.) the log event is sent.
In the examples of this chapter we will only use the xref:manual/appenders.adoc#consoleappender[console appender] and the xref:manual/appenders.adoc#fileappender[file appender] in the examples.
+
See xref:manual/appenders.adoc[Appender configuration] for details.

Layouts::
+
Layouts tell appenders how they should format the log event: text, JSON, XML, etc.
In the examples of this chapter we will only use the xref:manual/layouts.adoc#pattern-layout[textual pattern layout]
and
xref:manual/json-template-layout.adoc[JSON template layout] in the examples.
+
See xref:manual/layouts.adoc[Layout configuration] for details.

A moderately complex configuration might look like this:

[tabs]
====
XML::
+
[source,xml]
----
include::example$configuration/main-elements.xml[lines=1;18..-1]
----

JSON::
+
[source,json]
----
include::example$configuration/main-elements.json[]
----

YAML::
+
[source,yaml]
----
include::example$configuration/main-elements.yaml[lines=17..-1]
----

Java properties::
+
[source,properties]
----
include::example$configuration/main-elements.properties[lines=17..-1]
----
====

<1> Configures a console appender named `CONSOLE` with a pattern layout.
<2> Configures a file appender named `MAIN` with a JSON template layout.
<3> Configures a file appender named `DEBUG_LOG` with a pattern layout.
<4> Configures the root logger at level `INFO` and connects it to the `CONSOLE` and `MAIN` appenders.
The `CONSOLE` appender will only log messages less specific than `WARN`.
<5> Configures a logger named `"org.example"` at level `DEBUG` and connects it to the `DEBUG_LOG` appender.
The logger is configured to forward messages to its parent (the root appender).

[cols="2m,2m,5"]
|===
| Logger name | Log event level | Appenders

| org.example.foo
| WARN
| `CONSOLE`, `MAIN`, `DEBUG_LOG`

| org.example.foo
| DEBUG
| `MAIN`, `DEBUG_LOG`

| org.example.foo
| TRACE
| _none_

| com.example
| WARN
| `CONSOLE`, `MAIN`

| com.example
| INFO
| `MAIN`

| com.example
| DEBUG
| _none_

|===

[id=additional-configuration-elements]
=== Additional configuration elements

A Log4j Core configuration file can also contain these configuration elements:

CustomLevels::
+
Log4j allows to configure custom level names.
+
See xref:manual/customloglevels.adoc[Custom log level configuration] for details.

Filters::
+
Components that can be added to loggers, appender references, appenders or the global configuration object to provide additional filtering of log events.
+
See xref:manual/filters.adoc[Filter configuration] for details.

Properties::
+
A set of reusable configuration values for property substitution.
+
See <<property-substitution>> for details.

Scripts::
+
See xref:manual/scripts.adoc[Scripts configuration] for details.

[id=global-configuration-attributes]
=== Global configuration attributes

The main `Configuration` element has a set of attributes that can be used to tune the way the configuration file itself is used.
The principal attributes are listed below.
See xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-Configuration[Plugin reference] for a complete list.

[id=configuration-attribute-monitorInterval]
==== [[AutomaticReconfiguration]] `monitorInterval`

[cols="1h,5"]
|===
| Type          | `int`
| Default value | `0`
|===

Determines the polling interval used by Log4j to check for changes to the configuration file.

If a change in the configuration file is detected, Log4j automatically reconfigures the logger context.

If set to `0`, polling is disabled.

[CAUTION]
====
Unlike other logging backends Log4j Core is designed with **audit** logging in mind.

During a reconfiguration process, no messages are lost.

Unless the new configuration file removes an appender, the old one continues to work without interruption.
This behavior also implies that changes to appenders that modify the options of the resource used by the appender (e.g. a change in the `append` attribute of a file appender) will be **ignored**.
In order to modify these options during a reconfiguration you also need to change the resource used by the appender (e .g. the file name used by a file appender).
====

[id=configuration-attribute-status]
==== `status`

[cols="1h,5"]
|===
| Type          | link:../javadoc/log4j-api/org/apache/logging/log4j/Level.html[LEVEL]
| Status | **DEPRECATED**
| Default value (since 2.24.0) | xref:manual/systemproperties.adoc#log4j2.statusLoggerLevel[log4j2.statusLoggerLevel]
| Default value (before 2.24.0) | value of `log4j2.defaultStatusLevel`
|===

Overrides the logging level of the status logger.

WARNING: Since 2.24.0 this attribute is deprecated and will be replaced with the
xref:manual/systemproperties.adoc#log4j2.statusLoggerLevel[log4j2.statusLoggerLevel]
configuration property.

[id=configuration-elements-filters]
==== Filters

See xref:manual/filters.adoc#filters[Filters] for additional filtering capabilities that can be applied to the global configuration object.

[id=configuring-loggers]
=== [[Loggers]] Loggers

Log4j 2 contains multiple types of logger components that can be added to the `Loggers` element of the configuration:

`Root`:: is the logger that receives all events that do not have a more specific logger defined.
+
See also xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-LoggerConfig-RootLogger[Plugin reference].

`AsyncRoot`:: is an alternative implementation of the root logger used in the xref:manual/async.adoc#MixedSync-Async[mixed synchronous and asynchronous mode].
+
See also xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-async-AsyncLoggerConfig-RootLogger[Plugin reference].

`Logger`:: the most common logger kind, which collects log events from itself and all its children loggers, which do not have an explicit configuration (see xref:manual/architecture.adoc#logger-hierarchy[logger hierarchy]).
+
See also xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-LoggerConfig[Plugin Reference].

`AsyncLogger`:: the equivalent of `Logger`, used in the xref:manual/async.adoc#MixedSync-Async[mixed synchronous and asynchronous mode].
+
See also xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-async-AsyncLoggerConfig[Plugin Reference].

Every configuration **must** have at least a `Root` or `AsyncRoot` element.
The presence of other logger configurations is optional.

The logger components can have the following configuration attributes and elements:

[id=logger-attributes-name]
==== `name`

[cols="1h,5"]
|===
| Type          | `String`
| Applies to    | `Logger` and `AsyncLogger`
|===

Specifies the name of the logger configuration.

Since loggers are usually named using fully qualified class names, this value usually contains the fully qualified name of a class or a package.

[id=logger-attributes-additivity]
==== [[Additivity]] `additivity`

[cols="1h,5"]
|===
| Type          | `boolean`
| Default value | `true`
| Applies to    | `Logger` and `AsyncLogger`
|===

If `true` (default), all the messages received by this logger will also be transmitted to its parent logger.

[id=logger-attributes-level]
==== `level`

[cols="1h,5"]
|===
| Type          | link:../javadoc/log4j-api/org/apache/logging/log4j/Level.html[Level]
| Default value
a|
* xref:manual/systemproperties.adoc#log4j2.level[log4j2.level],
for `Root` and `AsyncRoot`,
* inherited from the parent logger, for `Logger` and `AsyncLogger`.
|===

Specifies the level threshold that a log event must have to be logged.
Log events more specific than this setting will be filtered out.

See also xref:manual/filters.adoc#filters[Filters] if you require additional filtering.

[id=logger-attributes-includeLocation]
==== `includeLocation`

[cols="1h,5"]
|===
| Type          | `boolean`
| Default value
a|
* `false`, if an asynchronous `ContextSelector` is used.
* Otherwise,
** `true` for `Root` and `Logger`,
** `false` for `AsyncRoot` and `AsyncLogger`.

See
xref:manual/systemproperties.adoc#log4j2.contextSelector[log4j2.contextSelector]
for more details.
|===

Specifies whether Log4j is allowed to compute location information.

Computing the location information of a logging statement is an expensive operation (a couple of microseconds).
While Log4j makes every effort to only compute it if it was requested by a configured layout (cf. xref:manual/layouts.adoc[Layouts]), this setting provide a kill switch to disable it.

[TIP]
====
This setting only applies to computation of location at **runtime**.

If the location is computed at build time using link:/log4j/transform/latest/#log4j-transform-maven-plugin[Log4j Transform Maven Plugin] this setting is ignored and location information will always be available for logging.
====

[id=logger-elements-appenderrefs]
==== Appender references

Loggers use appender references to list the appenders to use to deliver log events.

See <<configuring-appenderrefs>> below for more details.

[id=logger-elements-properties]
==== Additional context properties

Loggers can emit additional context data that will be integrated with other context data sources such as xref:manual/thread-context.adoc[ThreadContext].

[CAUTION]
====
The `value` of each property is subject to <<property-substitution,property substitution>> twice:

* when the configuration is loaded,
* each time a log event is generated.

Therefore, if you wish to insert a value that changes in time you must double the `$` sign as in the example below.
====

[tabs]
====
XML::
+
[source,xml]
----
include::example$configuration/logger-properties.xml[tag=loggers]
----

JSON::
+
[source,json]
----
include::example$configuration/logger-properties.json[tag=loggers]
----

YAML::
+
[source,yaml]
----
include::example$configuration/logger-properties.yaml[tag=loggers]
----

Java properties::
+
[source,properties]
----
include::example$configuration/logger-properties.properties[tag=loggers]
----
====

[id=logger-elements-filters]
==== Filters

See xref:manual/filters.adoc#filters[Filters] for additional filtering capabilities that can be applied to a logger configuration.

[id=configuring-appenderrefs]
=== Appender references

Many Log4j components such as loggers use appender references to designate, which appenders will be used to deliver their events.

Unlike Log4j 1, where appender references were simple pointers, in Log4j 2 they have additional filtering capabilities.

Appender references can have the following configuration attributes and elements:

[id=appenderref-attributes-name]
==== `ref`

[cols="1h,5"]
|===
| Type          | `String`
|===

Specifies the name of the appender to use.

[id=appenderref-attributes-level]
==== `level`

[cols="1h,5"]
|===
| Type          | link:../javadoc/log4j-api/org/apache/logging/log4j/Level.html[Level]
|===

Specifies the level threshold that a log event must have to be logged.
Log events more specific than this setting will be filtered out.

See also xref:manual/filters.adoc#filters[Filters] if you require additional filtering.

[id=appenderrefs-elements-filters]
==== Filters

See xref:manual/filters.adoc#filters[Filters] for additional filtering capabilities that can be applied to a logger configuration.

[id=property-substitution]
=== Property substitution

Log4j provides a simple and extensible mechanism to reuse values in the configuration file using `$\{name}` expressions, such as those used in Bash, Ant or Maven.

Reusable configuration values can be added directly to a configuration file by using a xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-PropertiesPlugin[Properties] component.

[tabs]
====
XML::
+
[source,xml]
----
include::example$configuration/properties.xml[lines=1;18..24;26]
----

JSON::
+
[source,json]
----
include::example$configuration/properties.json[]
----

YAML::
+
[source,yaml]
----
include::example$configuration/properties.yaml[lines=17..-1]
----

Java properties::
+
[source,properties]
----
include::example$configuration/properties.properties[lines=17..-1]
----
====

Reusable configuration values can be also provided by an extensible lookup mechanism.
See xref:manual/lookups.adoc[Lookup]s for more information.

Configuration values defined this way can be used in **any** configuration attribute by using the following expansion rules:

`$\{name}`::
+
If the `Properties` element of the configuration file has a property named `name` its value is substituted.
Otherwise, the placeholder is not expanded.
+
[WARNING]
====
If `name` contains a `:` character, it is expanded as in the rule below.
====

`${lookup:name}`::
If both these conditions hold:
+
--
* `lookup` is a prefix assigned to a xref:manual/lookups.adoc[Lookup],
* the lookup has a value assigned to `name`,
--
+
the value for the lookup is a substituted.
Otherwise, the expansion of `$\{name}` is substituted.
+
If `name` starts with a hyphen `-` (e.g. `-variable`), it must be escaped with a backslash `\` (e.g. `\-variable`).
+
The most common lookup prefixes are:
+
* `sys` for Java system properties (see xref:manual/lookups.adoc#system-properties-lookup[System Properties lookup]),
* `env` for environment variables (see xref:manual/lookups.adoc#environment-lookup[Environment lookup]).

The above expansions have a version with an additional `default` value that is **expanded** if the lookup fails:

`${name:-default}`::
+
If the `Properties` element of the configuration file has a property named `name` its value is substituted.
Otherwise, the **expansion** of `default` is substituted.
+
[WARNING]
====
If `name` contains a `:` character, it is expanded as in the rule below.
====

`${lookup:name:-default}`::
+
If both these conditions hold:
+
--
* `lookup` is a prefix assigned to a xref:manual/lookups.adoc[Lookup],
* the lookup has a value assigned to `name`,
--
+
the value for the lookup is a substituted.
Otherwise, the expansion of `$\{name:-default}` is substituted.

[NOTE]
====
To prevent the expansion of one of the expression above, the initial `$` must be doubled as `$$`.

The same rule applies to the `name` parameter: if it contains a `${` sequence, the sequence must be escaped as `$${`.
====

[id=lazy-property-substitution]
==== Lazy property substitution

While property substitution is performed once at **configuration time** for most attributes, there are two exceptions to this rule:

* Some attributes are **also** evaluated when a component specific event occurs.
For example
<<logger-elements-properties,additional context properties>>
and the `pattern` attribute of the example below are evaluated at each log event, while the `filePattern` attribute of a
xref:manual/appenders.adoc#rollingfileappender[rolling file appender]
is evaluated at each rollover.
+
In this case:

** If you want property substitution to happen only once, you use one dollar sign, e.g. `${date:HH:mm:ss}`.
** If you want property substitution to happen at each cyclic event, you use two dollar signs, e.g. `$${date:HH:mm:ss}`

* Other components defer the evaluation of their children components.
In this case you only need one dollar `$` sign.
+
This case happens for the children of the `Route` element below:

[tabs]
====
XML::
+
[source,xml]
----
include::example$configuration/routing.xml[tag=appender]
----

JSON::
+
[source,json]
----
include::example$configuration/routing.json[tag=appender]
----

YAML::
+
[source,yaml]
----
include::example$configuration/routing.yaml[tag=appender]
----

Java properties::
+
[source,properties]
----
include::example$configuration/routing.properties[tag=appender]
----
====

<1> The `pattern` attribute is evaluated at configuration time and also each time a log event is routed.
Therefore, the dollar `$` sign needs to be escaped.
<2> All the attributes inside the `File` element have a **deferred** evaluation, therefore they need only one `$` sign.

[id=arbiters]
=== [[Arbiters]] Arbiters

While property substitution allows to use the same configuration file in multiple deployment environments, sometimes changing the values of configuration attributes is not enough.

Arbiters are to configuration elements what property substitution is for configuration attributes: they allow to conditionally add a subtree of configuration elements to a configuration file.

Arbiters may occur anywhere an element is allowed in the configuration and can be nested.
So an Arbiter could encapsulate something as simple as a single property declaration or a whole set of appenders, loggers or other arbiters.
The child elements of an arbiter must be valid elements for whatever element is the parent of the arbiter.

For a complete list of available arbiters see
xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-arbiters-Arbiter[plugin reference].
In the examples below we'll just use the
xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-arbiters-DefaultArbiter[DefaultArbiter],
xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-arbiters-SelectArbiter[Select]
and
xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-arbiters-SystemPropertyArbiter[SystemPropertyArbiter].

For example, you might want to use a different layout in a production and development environment:

[tabs]
====
XML::
+
[source,xml]
----
include::example$configuration/arbiters.xml[lines=1;18..-1]
----

JSON::
+
[source,json]
----
include::example$configuration/arbiters.json[]
----

YAML::
+
[source,yaml]
----
include::example$configuration/arbiters.yaml[lines=17..-1]
----

Java properties::
+
[source,properties]
----
include::example$configuration/arbiters.properties[lines=17..-1]
----
====

<1> If the Java system property `env` has a value of `dev`, a pattern layout will be used.
<2> If the Java system property `env` has a value of `prod`, a JSON template layout will be used.

The above example has a problem: if the Java system property `env` has a value different from `dev` or `prod`, the appender will have no layout.

This is a case, when the `Select` plugin is useful: this configuration element contains a list of arbiters and a
`DefaultArbiter` element.
If none of the arbiters match, the configuration from the `DefaultArbiter` element will be used:

[tabs]
====
XML::
+
[source,xml]
----
include::example$configuration/arbiters-select.xml[lines=1;18..-1]
----

JSON::
+
[source,json]
----
include::example$configuration/arbiters-select.json[]
----

YAML::
+
[source,yaml]
----
include::example$configuration/arbiters-select.yaml[lines=17..-1]
----

Java properties::
+
[source,properties]
----
include::example$configuration/arbiters-select.properties[lines=17..-1]
----
====

<1> If the Java system property `env` has a value of `dev`, a pattern layout will be used.
<2> Otherwise, a JSON template layout will be used.

[#CompositeConfiguration]
=== Composite Configuration

Log4j allows multiple configuration files to be used at the same time by specifying them as a list of comma separated file paths or URLs in the
xref:manual/systemproperties.adoc#log4j2.configurationFile[log4j2.configurationFile]
configuration property.

These configuration files are merged into a single configuration file using
link:../javadoc/log4j-core/org/apache/logging/log4j/core/config/composite/MergeStrategy.html[MergeStrategy]
service that can be customized using the
xref:manual/systemproperties.adoc#log4j2.mergeStrategy[log4j2.mergeStrategy]
configuration property.

The default merge strategy will merge the files using the following rules:

. <<global-configuration-attributes>> in later configurations replace those in previous configurations.
+
The exception is the `monitorInterval` attribute: the lowest positive value from all the configuration files will be used.

. <<property-substitution,Properties>> from all configurations are aggregated.
Duplicate properties replace those in previous configurations.

. xref:manual/filters.adoc[Filters] are aggregated under
xref:manual/filters.adoc#CompositeFilter[CompositeFilter], if more than one filter is defined.

. xref:manual/scripts.adoc[] are aggregated.
Duplicate definitions replace those in previous configurations.

. xref:manual/appenders.adoc[Appenders] are aggregated.
Appenders with the same name are **replaced** by those in later configurations, including all their elements.

. <<configuring-loggers,Loggers>> are all aggregated.
Logger attributes are individually merged with duplicates being replaced by those in later configurations.
Appender references on a logger are aggregated with duplicates being replaced by those in later configurations.
The strategy merges filters on loggers using the rule above.

[id=format-specific-notes]
=== Format specific notes

[id=xml-features]
==== XML format

[id=xml-global-configuration-attributes]
===== Global configuration attributes

The XML format supports the following additional attributes on the `Configuration` element.

[id=configuration-attribute-schema]
====== `schema`

[cols="1h,5"]
|===
| Type          | classpath resource
| Default value | `null`
|===

Specifies the path to a classpath resource containing an XML schema.

[id=configuration-attribute-strict]
====== `strict`

[cols="1h,5"]
|===
| Type          | `boolean`
| Default value | `false`
|===

If set to `true` all configuration files will be checked against the XML schema provided by the
<<configuration-attribute-schema>>.

This setting also enables "XML strict mode" and allows to specify the **plugin type** of an element through a `type` attribute instead of the tag name.

[id=xinclude]
===== [[XInlcude]] XInclude

XML configuration files can include other files with
https://www.w3.org/TR/xinclude/[XInclude].

NOTE: The list of `XInclude` and `XPath` features supported depends upon your
https://docs.oracle.com/javase/{java-target-version}/docs/technotes/guides/xml/jaxp/index.html[JAXP implementation].

Here is an example log4j2.xml file that includes two other files:

.log4j2.xml
[source,xml]
----
include::example$configuration/xinclude-main.xml[lines=1;18..-1]
----

.xinclude-appenders.xml
[source,xml]
----
include::example$configuration/xinclude-appenders.xml[lines=1;18..-1]
----

.xinclude-loggers.xml
[source,xml]
----
include::example$configuration/xinclude-loggers.xml[lines=1;18..-1]
----

[id=java-properties-features]
==== Java properties format

The Java properties configuration format is by far the most verbose of the available formats.
In order to make it more usable a series of exceptions to the rules in <<configuration-with-properties,Java properties syntax>> have been introduced over time:

. The following direct children of `Configuration` have predefined prefixes and do not require to specify a `type`
attribute:
* The xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-AppendersPlugin[Appender container] has a predefined `appender` prefix.
* The xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-CustomLevels[Custom levels container] has a predefined `customLevel` prefix.
* The xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-LoggersPlugin[Loggers container] has a predefined `logger` prefix.
* The xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-PropertiesPlugin[Properties container] has a predefined `property` prefix.
* The xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-config-ScriptsPlugin[Scripts container] has a predefined `script` prefix.

. Properties that start with `property` are used for <<property-substitution>>.
Their syntax is:
+
[source,properties]
----
property.<key> = <value>
----

. Properties that start with `customLevel` are used to define custom levels Their syntax is:
+
[source,properties]
----
customLevel.<name> = <intValue>
----
+
where `<name>` is the name of the level and `<intValue>` its numerical value.

. The root logger can be configured using properties that start with `rootLogger`.

. A shorthand notation is available that allows users to write:
+
[source,properties]
----
rootLogger = INFO, APPENDER
----
+
instead of:
+
[source,properties]
----
rootLogger.level = INFO
rootLogger.appenderRef.0.ref = APPENDER
----

. All the keys of the form `logger.<name>.appenderRef.<id>`, where `<name>` and `<id>` are arbitrary, are considered appender references.

. To add a filter to a component use a `filter.<id>` prefix instead of just `<id>`.
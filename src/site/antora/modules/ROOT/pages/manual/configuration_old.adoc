////
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
////
[#configuration]
= Configuration
Ralph Goers <rgoers@apache.org>

[#Arbiters]
== Arbiters

In some situations it is desirable to have a single logging configuration that can be used in any
deployment environment. For example, it may be necessary to have a different default logging level in
production then in development. Another case might be where one type of appender is used when running
natively but another is used when deployed to a docker container. One way to handle that is to use
a tool such as Spring Cloud Config Server that can be environment aware and serve a different file for
each environment. Another option is to include Arbiters in the configuration.

An Arbiter is a Log4j plugin that has the job of determining whether other configured elements should be
included in the generated configuration. While all other "Core" plugins are designed to execute as part of
Log4j's runtime logic Arbiters execute after the Node tree has been constructed but before the tree is
converted to a configuration. An Arbiter is a Node itself which is always removed from the Node tree
before it the tree is processed. All an arbiter really does is provide a method that returns a boolean
result that determines whether the child nodes of the arbiter should remain in the configuration or be
pruned.

Arbiters may occur anywhere an element is allowed in the configuration. So an Aribiter could encapsulate
something as simple as a single property declaration or a whole set of Appenders or Loggers. Arbiters
may also be nested although Arbiters that are the descendant of another arbiter will only be evalued if the
ancestor returned true. The child elements of an Arbiter must be valid elements for whatever element is
the parent of the Arbiter.

This example shows two Arbiters configured that will include either a Console Appender or a List Appender
depending on whether the value of the env System Property is "dev" or "prod".

[source,xml]
----
<Configuration name="ConfigTest" status="ERROR" monitorInterval="5">
  <Appenders>

    <SystemPropertyArbiter propertyName="env" propertyValue="dev">
      <Console name="Out">
        <PatternLayout pattern="%m%n"/>
      </Console>
    </SystemPropertyArbiter>
    <SystemPropertyArbiter propertyName="env" propertyValue="prod">
      <List name="Out">
      </List>
    </SystemPropertyArbiter>

  </Appenders>
  <Loggers>
    <Logger name="org.apache.test" level="trace" additivity="false">
      <AppenderRef ref="Out"/>
    </Logger>
    <Root level="error">
      <AppenderRef ref="Out"/>
    </Root>
  </Loggers>
</Configuration>
----

Normally Arbiters act in isolation from other Arbiters. That is, the outcome of one Arbiter will not
impact any other Arbiters. This can be cumbersome when you simply want to use one of a set of choices. A
special plugin named "Select" can be used in this case. Each element under the Select is required to be
an Arbiter. The first Arbiter that returns a true value will be the one used while others are ignored.
If no Arbiter returns true a DefaultAtrbiter may be configured with the default configuration elements.
The DefaultArbiter is an Arbiter that always returns true, so using it outside of a Select would result in
its configured elements always being included just as if it hadn't been present.

This example shows an Arbiter that uses Javascript residing in a separate file to determine whether to
include the Console Appender. If the result is false then a List Appender will be included.

[source,xml]
----
<Configuration name="ConfigTest" status="ERROR" monitorInterval="5">
  <Appenders>
    <Select>
      <ScriptArbiter>
        <ScriptFile language="JavaScript" path="src/test/resources/scripts/prodtest.js" charset="UTF-8" />
        <Console name="Out">
          <PatternLayout pattern="%m%n"/>
        </Console>
      </ScriptArbiter>
      <DefaultArbiter>
        <List name="Out">
        </List>
      </DefaultArbiter>
    </Select>
  </Appenders>
  <Loggers>
    <Logger name="org.apache.test" level="trace" additivity="false">
      <AppenderRef ref="Out"/>
    </Logger>
    <Root level="error">
      <AppenderRef ref="Out"/>
    </Root>
  </Loggers>
</Configuration>
----

Natively Log4j contains the SystemProperty Arbiter that can evaluate whether to include elements based on
whether a SystemProperty is non-null or has a specific value, a ClassArbiter that makes its decision
based on whether the specified class is present, and a ScriptArbiter that makes its decision based
on the result of the script configured with it.

For Spring Boot users an Arbiter named <code>SpringProfile</code> has been provided. The specified profiles
are evaluated by Spring's <code>Environment.acceptsProfiles()</code> method, so any expressions it supports
may be used as the name attribute.

This example will use a Console Appender when the Spring profile is "dev" or "staging" and a List
Appender when the active profile is "prod".

[source,xml]
----
<Configuration name="ConfigTest" status="ERROR" monitorInterval="5">
  <Appenders>

    <SpringProfile name="dev | staging">
      <Console name="Out">
        <PatternLayout pattern="%m%n"/>
      </Console>
    </SpringProfile>
    <SpringProfile name="prod">
      <List name="Out">
      </List>
    </SpringProfile>

  </Appenders>
  <Loggers>
    <Logger name="org.apache.test" level="trace" additivity="false">
      <AppenderRef ref="Out"/>
    </Logger>
    <Root level="error">
      <AppenderRef ref="Out"/>
    </Root>
  </Loggers>
</Configuration>
----

* A
link:../javadoc/log4j-core/org/apache/logging/log4j/core/appender/ConsoleAppender.html[`ConsoleAppender`]
attached to the root logger.
* A
link:../javadoc/log4j-core/org/apache/logging/log4j/core/layout/PatternLayout.html[`PatternLayout`]
set to the pattern "%d\{HH:mm:ss.SSS} [%t] %-5level %logger\{36} -
%msg%n" attached to the ConsoleAppender

Note that by default Log4j assigns the root logger to `Level.ERROR`.

The output of MyApp would be similar to:

....
17:13:01.540 [main] ERROR com.foo.Bar - Did it again!
17:13:01.540 [main] ERROR MyApp - Didn't do it.
....

As was described previously, Log4j will first attempt to configure
itself from configuration files. A configuration equivalent to the
default would look like:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
  </Appenders>
  <Loggers>
    <Root level="error">
      <AppenderRef ref="Console"/>
    </Root>
  </Loggers>
</Configuration>
----

Once the file above is placed into the classpath as log4j2.xml you will
get results identical to those listed above. Changing the root level to
trace will result in results similar to:

....
17:13:01.540 [main] TRACE MyApp - Entering application.
17:13:01.540 [main] TRACE com.foo.Bar - entry
17:13:01.540 [main] ERROR com.foo.Bar - Did it again!
17:13:01.540 [main] TRACE com.foo.Bar - exit with (false)
17:13:01.540 [main] ERROR MyApp - Didn't do it.
17:13:01.540 [main] TRACE MyApp - Exiting application.
....

Note that status logging is disabled when the default configuration is
used.

[#Additivity]
== Additivity

Perhaps it is desired to eliminate all the TRACE output from everything
except `com.foo.Bar`. Simply changing the log level would not accomplish
the task. Instead, the solution is to add a new logger definition to the
configuration:

[source,xml]
----
<Configuration>
  <!-- ... -->
  <Logger name="com.foo.Bar" level="TRACE"/>
  <Root level="ERROR">
    <AppenderRef ref="STDOUT"/>
  </Root>
</Configuration>
----

With this configuration all log events from `com.foo.Bar` will be
recorded while only error events will be recorded from all other
components.

In the previous example all the events from `com.foo.Bar` were still
written to the Console. This is because the logger for `com.foo.Bar` did
not have any appenders configured while its parent did. In fact, the
following configuration

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
  </Appenders>
  <Loggers>
    <Logger name="com.foo.Bar" level="trace">
      <AppenderRef ref="Console"/>
    </Logger>
    <Root level="error">
      <AppenderRef ref="Console"/>
    </Root>
  </Loggers>
</Configuration>
----

would result in

....
17:13:01.540 [main] TRACE com.foo.Bar - entry
17:13:01.540 [main] TRACE com.foo.Bar - entry
17:13:01.540 [main] ERROR com.foo.Bar - Did it again!
17:13:01.540 [main] TRACE com.foo.Bar - exit (false)
17:13:01.540 [main] TRACE com.foo.Bar - exit (false)
17:13:01.540 [main] ERROR MyApp - Didn't do it.
....

Notice that the trace messages from `com.foo.Bar` appear twice. This is
because the appender associated with logger `com.foo.Bar` is first used,
which writes the first instance to the Console. Next, the parent of
`com.foo.Bar`, which in this case is the root logger, is referenced. The
event is then passed to its appender, which is also writes to the
Console, resulting in the second instance. This is known as additivity.
While additivity can be quite a convenient feature (as in the first
previous example where no appender reference needed to be configured),
in many cases this behavior is considered undesirable and so it is
possible to disable it by setting the additivity attribute on the logger
to false:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
  </Appenders>
  <Loggers>
    <Logger name="com.foo.Bar" level="trace" additivity="false">
      <AppenderRef ref="Console"/>
    </Logger>
    <Root level="error">
      <AppenderRef ref="Console"/>
    </Root>
  </Loggers>
</Configuration>
----

Once an event reaches a logger with its additivity set to false the
event will not be passed to any of its parent loggers, regardless of
their additivity setting.

[#Appenders]
=== Configuring Appenders

An appender is configured either using the specific appender plugin's
name or with an appender element and the type attribute containing the
appender plugin's name. In addition each appender must have a name
attribute specified with a value that is unique within the set of
appenders. The name will be used by loggers to reference the appender as
described in the previous section.

Most appenders also support a layout to be configured (which again may
be specified either using the specific Layout plugin's name as the
element or with "layout" as the element name along with a type attribute
that contains the layout plugin's name. The various appenders will
contain other attributes or elements that are required for them to
function properly.

[#Scripts]
== Scripts

Log4j provides support for
https://docs.oracle.com/javase/6/docs/technotes/guides/scripting/[JSR
223] scripting languages to be used in some of its components. Any
language that provides support for the JSR 223 scripting engine may be
used. A list of the languages and bindings for them can be found at the
https://java.net/projects/scripting/sources/svn/show/trunk/engines[Scripting
Engine] web site. However, some of the languages listed there, such as
JavaScript, Groovy and Beanshell, directly support the JSR 223 scripting
framework and only require that the jars for that language be installed.

As of Log4j 2.17.2 the languages to be supported must be specified as a comma separated list in the
`log4j2.Script.enableLanguages` system property.

The components that support using scripts do so by allowing a `<script>`,
`<scriptFile>`, or `<scriptRef>` element to be configured on them. The
script element contains a name for the script, the language of the
script, and the script text. The scriptFile element contains the name of
the script, its location, its language, its charset, and whether the
file should be watched for changes. The scriptRef element contains the
name of the script that is defined in the `<scripts>` configuration
element. The name of the script is used to store the script, along with
its ScriptEngine, so it can quickly be located each time the script
needs to be run. While the name is not required, providing it will help
in debugging problems when the script is running. The language must be
provided on the script element and must specify one of the language
names that appear in the Configuration status log as described in the
next section. If the language is not specified on the scriptFile element
the language will be determined by the file extension of the script
path. If file monitoring is requested it will only be enabled if a
non-zero monitorInterval is specified on the configuration element. That
interval will be used to check for changes in the file.

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="debug" name="RoutingTest">
  <Scripts>
    <Script name="selector" language="javascript"><![CDATA[
            var result;
            if (logEvent.getLoggerName().equals("JavascriptNoLocation")) {
                result = "NoLocation";
            } else if (logEvent.getMarker() != null && logEvent.getMarker().isInstanceOf("FLOW")) {
                result = "Flow";
            }
            result;
            ]]></Script>
    <ScriptFile name="groovy.filter" path="scripts/filter.groovy"/>
  </Scripts>

  <Appenders>
    <Console name="STDOUT">
      <ScriptPatternSelector defaultPattern="%d %p %m%n">
        <ScriptRef ref="selector"/>
          <PatternMatch key="NoLocation" pattern="[%-5level] %c{1.} %msg%n"/>
          <PatternMatch key="Flow" pattern="[%-5level] %c{1.} ====== %C{1.}.%M:%L %msg ======%n"/>
      </ScriptPatternSelector>
      <PatternLayout pattern="%m%n"/>
    </Console>
  </Appenders>

  <Loggers>
    <Logger name="EventLogger" level="info" additivity="false">
        <ScriptFilter onMatch="ACCEPT" onMisMatch="DENY">
          <Script name="GroovyFilter" language="groovy"><![CDATA[
            if (logEvent.getMarker() != null && logEvent.getMarker().isInstanceOf("FLOW")) {
                return true;
            } else if (logEvent.getContextMap().containsKey("UserId")) {
                return true;
            }
            return false;
            ]]>
          </Script>
        </ScriptFilter>
      <AppenderRef ref="STDOUT"/>
    </Logger>

    <Root level="error">
      <ScriptFilter onMatch="ACCEPT" onMisMatch="DENY">
        <ScriptRef ref="groovy.filter"/>
      </ScriptFilter>
      <AppenderRef ref="STDOUT"/>
    </Root>
  </Loggers>

</Configuration>
----

If the status attribute on the Configuration element is set to DEBUG the
list of script engines currently installed and their attributes will be
listed. Although some engines may say they are not thread safe, Log4j
takes steps to insure that the scripts will run in a thread-safe manner
if the engine advertises that it is not thread safe.

....
2015-09-27 16:13:22,925 main DEBUG Installed script engines
2015-09-27 16:13:22,963 main DEBUG AppleScriptEngine Version: 1.1, Language: AppleScript, Threading: Not Thread Safe,
            Compile: false, Names: {AppleScriptEngine, AppleScript, OSA}
2015-09-27 16:13:22,983 main DEBUG Groovy Scripting Engine Version: 2.0, Language: Groovy, Threading: MULTITHREADED,
            Compile: true, Names: {groovy, Groovy}
2015-09-27 16:13:23,030 main DEBUG BeanShell Engine Version: 1.0, Language: BeanShell, Threading: MULTITHREADED,
            Compile: true, Names: {beanshell, bsh, java}
2015-09-27 16:13:23,039 main DEBUG Mozilla Rhino Version: 1.7 release 3 PRERELEASE, Language: ECMAScript, Threading: MULTITHREADED,
            Compile: true, Names: {js, rhino, JavaScript, javascript, ECMAScript, ecmascript}
....

When the scripts are executed they will be provided with a set of
variables that should allow them to accomplish whatever task they are
expected to perform. See the documentation for the individual components
for the list of variables that are available to the script.

The components that support scripting expect a return value to be passed
back to the calling Java code. This is not a problem for several of the
scripting languages, but Javascript does not allow a return statement
unless it is within a function. However, Javascript will return the
value of the last statement executed in the script. As a consequence,
code such as that shown below will result in the desired behavior.

[source,javascript]
----
var result;
if (logEvent.getLoggerName().equals("JavascriptNoLocation")) {
    result = "NoLocation";
} else if (logEvent.getMarker() != null && logEvent.getMarker().isInstanceOf("FLOW")) {
    result = "Flow";
}
result;
----

=== A special note on Beanshell

JSR 223 scripting engines are supposed to identify that they support the
Compilable interface if they support compiling their scripts. Beanshell
does this. However, whenever the compile method is called it throws an
Error (not an Exception). Log4j catches this but will log the warning
shown below for each Beanshell script when it tries to compile them. All
Beanshell scripts will then be interpreted on each execution.

....
2015-09-27 16:13:23,095 main DEBUG Script BeanShellSelector is compilable
2015-09-27 16:13:23,096 main WARN Error compiling script java.lang.Error: unimplemented
            at bsh.engine.BshScriptEngine.compile(BshScriptEngine.java:175)
            at bsh.engine.BshScriptEngine.compile(BshScriptEngine.java:154)
            at org.apache.logging.log4j.core.script.ScriptManager$MainScriptRunner.<init>(ScriptManager.java:125)
            at org.apache.logging.log4j.core.script.ScriptManager.addScript(ScriptManager.java:94)
          
....

[#XInclude]
== XInclude

XML configuration files can include other files with
http://www.xml.com/lpt/a/1009[XInclude]. Here is an example log4j2.xml
file that includes two other files:

.log4j2.xml
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<configuration xmlns:xi="http://www.w3.org/2001/XInclude"
               status="warn" name="XIncludeDemo">
  <properties>
    <property name="filename">xinclude-demo.log</property>
  </properties>
  <ThresholdFilter level="debug"/>
  <xi:include href="log4j-xinclude-appenders.xml" />
  <xi:include href="log4j-xinclude-loggers.xml" />
</configuration>
----

.log4j-xinclude-appenders.xml
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<appenders>
  <Console name="STDOUT">
    <PatternLayout pattern="%m%n" />
  </Console>
  <File name="File" fileName="${filename}" bufferedIO="true" immediateFlush="true">
    <PatternLayout>
      <pattern>%d %p %C{1.} [%t] %m%n</pattern>
    </PatternLayout>
  </File>
</appenders>
----

.log4j-xinclude-loggers.xml
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<loggers>
  <logger name="org.apache.logging.log4j.test1" level="debug" additivity="false">
    <ThreadContextMapFilter>
      <KeyValuePair key="test" value="123" />
    </ThreadContextMapFilter>
    <AppenderRef ref="STDOUT" />
  </logger>

  <logger name="org.apache.logging.log4j.test2" level="debug" additivity="false">
    <AppenderRef ref="File" />
  </logger>

  <root level="error">
    <AppenderRef ref="STDOUT" />
  </root>
</loggers>
----

[#CompositeConfiguration]
== Composite Configuration

Log4j allows multiple configuration files to be used by specifying them
as a list of comma separated file paths on log4j2.configurationFile or,
when using URLs, by adding secondary configuration locations as query
parameters named "override". The merge logic can be controlled by specifying
a class that implements the MergeStrategy interface on the log4j.mergeStrategy
property. The default merge strategy will merge the files using the following rules:

1.  The global configuration attributes are aggregated with those in
later configurations replacing those in previous configurations, with
the exception that the highest status level and the lowest
monitorInterval greater than 0 will be used.
2.  Properties from all configurations are aggregated. Duplicate
properties replace those in previous configurations.
3.  Filters are aggregated under a CompositeFilter if more than one
Filter is defined. Since Filters are not named duplicates may be
present.
4.  Scripts and ScriptFile references are aggregated. Duplicate
definitions replace those in previous configurations.
5.  Appenders are aggregated. Appenders with the same name are replaced
by those in later configurations, including all of the Appender's
subcomponents.
6.  Loggers are all aggregated. Logger attributes are individually
merged with duplicates being replaced by those in later configurations.
Appender references on a Logger are aggregated with duplicates being
replaced by those in later configurations. Filters on a Logger are
aggregated under a CompositeFilter if more than one Filter is defined.
Since Filters are not named duplicates may be present. Filters under
Appender references included or discarded depending on whether their
parent Appender reference is kept or discarded.

[#StatusMessages]
== Status Messages

****
*Troubleshooting tip for the impatient:*

From log4j-2.9 onward, log4j2 will print all internal logging to the
console if system property `log4j2.debug` is either defined empty or its value
equals to `true` (ignoring case).

Prior to log4j-2.9, there are two places where internal logging can be
controlled:

* Before a configuration is found, status logger level can be controlled
with system property
`org.apache.logging.log4j.simplelog.StatusLogger.level`.
* After a configuration is found, status logger level can be controlled
in the configuration file with the "status" attribute, for example:
`<Configuration status="trace">`.
****

Just as it is desirable to be able to diagnose problems in applications,
it is frequently necessary to be able to diagnose problems in the
logging configuration or in the configured components. Since logging has
not been configured, "normal" logging cannot be used during
initialization. In addition, normal logging within appenders could
create infinite recursion which Log4j will detect and cause the
recursive events to be ignored. To accomodate this need, the Log4j 2 API
includes a
link:../javadoc/log4j-api/org/apache/logging/log4j/status/StatusLogger.html[`StatusLogger`].
Components declare an instance of the StatusLogger similar to:

[source,java]
----
protected final static Logger logger = StatusLogger.getLogger();
----

Since StatusLogger implements the Log4j 2 API's Logger interface, all
the normal Logger methods may be used.

When configuring Log4j it is sometimes necessary to view the generated status events.
This can be accomplished by adding the status attribute to the configuration element or a default value can be provided by setting the xref:statusLoggerLevel["log4j2.statusLoggerLevel"] system property.
Valid values of the status attribute are "trace", "debug", "info", "warn", "error" and "fatal".
The following configuration has the status attribute set to debug.

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="debug" name="RoutingTest">
  <Properties>
    <Property name="filename">target/rolling1/rollingtest-$${sd:type}.log</Property>
  </Properties>
  <ThresholdFilter level="debug"/>

  <Appenders>
    <Console name="STDOUT">
      <PatternLayout pattern="%m%n"/>
      <ThresholdFilter level="debug"/>
    </Console>
    <Routing name="Routing">
      <Routes pattern="$${sd:type}">
        <Route>
          <RollingFile name="Rolling-${sd:type}" fileName="${filename}"
                       filePattern="target/rolling1/test1-${sd:type}.%i.log.gz">
            <PatternLayout>
              <pattern>%d %p %c{1.} [%t] %m%n</pattern>
            </PatternLayout>
            <SizeBasedTriggeringPolicy size="500" />
          </RollingFile>
        </Route>
        <Route ref="STDOUT" key="Audit"/>
      </Routes>
    </Routing>
  </Appenders>

  <Loggers>
    <Logger name="EventLogger" level="info" additivity="false">
      <AppenderRef ref="Routing"/>
    </Logger>

    <Root level="error">
      <AppenderRef ref="STDOUT"/>
    </Root>
  </Loggers>

</Configuration>
----

During startup this configuration produces:

....
2011-11-23 17:08:00,769 DEBUG Generated plugins in 0.003374000 seconds
2011-11-23 17:08:00,789 DEBUG Calling createProperty on class org.apache.logging.log4j.core.config.Property for element property with params(name="filename", value="target/rolling1/rollingtest-${sd:type}.log")
2011-11-23 17:08:00,792 DEBUG Calling configureSubstitutor on class org.apache.logging.log4j.core.config.PropertiesPlugin for element properties with params(properties={filename=target/rolling1/rollingtest-${sd:type}.log})
2011-11-23 17:08:00,794 DEBUG Generated plugins in 0.001362000 seconds
2011-11-23 17:08:00,797 DEBUG Calling createFilter on class org.apache.logging.log4j.core.filter.ThresholdFilter for element ThresholdFilter with params(level="debug", onMatch="null", onMismatch="null")
2011-11-23 17:08:00,800 DEBUG Calling createLayout on class org.apache.logging.log4j.core.layout.PatternLayout for element PatternLayout with params(pattern="%m%n", Configuration(RoutingTest), null, charset="null")
2011-11-23 17:08:00,802 DEBUG Generated plugins in 0.001349000 seconds
2011-11-23 17:08:00,804 DEBUG Calling createAppender on class org.apache.logging.log4j.core.appender.ConsoleAppender for element Console with params(PatternLayout(%m%n), null, target="null", name="STDOUT", ignoreExceptions="null")
2011-11-23 17:08:00,804 DEBUG Calling createFilter on class org.apache.logging.log4j.core.filter.ThresholdFilter for element ThresholdFilter with params(level="debug", onMatch="null", onMismatch="null")
2011-11-23 17:08:00,813 DEBUG Calling createRoute on class org.apache.logging.log4j.core.appender.routing.Route for element Route with params(AppenderRef="null", key="null", Node=Route)
2011-11-23 17:08:00,823 DEBUG Calling createRoute on class org.apache.logging.log4j.core.appender.routing.Route for element Route with params(AppenderRef="STDOUT", key="Audit", Node=Route)
2011-11-23 17:08:00,825 DEBUG Calling createRoutes on class org.apache.logging.log4j.core.appender.routing.Routes for element Routes with params(pattern="${sd:type}", routes={Route(type=dynamic default), Route(type=static Reference=STDOUT key='Audit')})
2011-11-23 17:08:00,827 DEBUG Calling createAppender on class org.apache.logging.log4j.core.appender.routing.RoutingAppender for element Routing with params(name="Routing", ignoreExceptions="null", Routes({Route(type=dynamic default),Route(type=static Reference=STDOUT key='Audit')}), Configuration(RoutingTest), null, null)
2011-11-23 17:08:00,827 DEBUG Calling createAppenders on class org.apache.logging.log4j.core.config.AppendersPlugin for element appenders with params(appenders={STDOUT, Routing})
2011-11-23 17:08:00,828 DEBUG Calling createAppenderRef on class org.apache.logging.log4j.core.config.plugins.AppenderRefPlugin for element AppenderRef with params(ref="Routing")
2011-11-23 17:08:00,829 DEBUG Calling createLogger on class org.apache.logging.log4j.core.config.LoggerConfig for element logger with params(additivity="false", level="info", name="EventLogger", AppenderRef={Routing}, null)
2011-11-23 17:08:00,830 DEBUG Calling createAppenderRef on class org.apache.logging.log4j.core.config.plugins.AppenderRefPlugin for element AppenderRef with params(ref="STDOUT")
2011-11-23 17:08:00,831 DEBUG Calling createLogger on class org.apache.logging.log4j.core.config.LoggerConfig$RootLogger for element root with params(additivity="null", level="error", AppenderRef={STDOUT}, null)
2011-11-23 17:08:00,833 DEBUG Calling createLoggers on class org.apache.logging.log4j.core.config.LoggersPlugin for element loggers with params(loggers={EventLogger, root})
2011-11-23 17:08:00,834 DEBUG Reconfiguration completed
2011-11-23 17:08:00,846 DEBUG Calling createLayout on class org.apache.logging.log4j.core.layout.PatternLayout for element PatternLayout with params(pattern="%d %p %c{1.} [%t] %m%n", Configuration(RoutingTest), null, charset="null")
2011-11-23 17:08:00,849 DEBUG Calling createPolicy on class org.apache.logging.log4j.core.appender.rolling.SizeBasedTriggeringPolicy for element SizeBasedTriggeringPolicy with params(size="500")
2011-11-23 17:08:00,851 DEBUG Calling createAppender on class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile with params(fileName="target/rolling1/rollingtest-Unknown.log", filePattern="target/rolling1/test1-Unknown.%i.log.gz", append="null", name="Rolling-Unknown", bufferedIO="null", immediateFlush="null", SizeBasedTriggeringPolicy(SizeBasedTriggeringPolicy(size=500)), null, PatternLayout(%d %p %c{1.} [%t] %m%n), null, ignoreExceptions="null")
2011-11-23 17:08:00,858 DEBUG Generated plugins in 0.002014000 seconds
2011-11-23 17:08:00,889 DEBUG Reconfiguration started for context sun.misc.Launcher$AppClassLoader@37b90b39
2011-11-23 17:08:00,890 DEBUG Generated plugins in 0.001355000 seconds
2011-11-23 17:08:00,959 DEBUG Generated plugins in 0.001239000 seconds
2011-11-23 17:08:00,961 DEBUG Generated plugins in 0.001197000 seconds
2011-11-23 17:08:00,965 WARN No Loggers were configured, using default
2011-11-23 17:08:00,976 DEBUG Reconfiguration completed
....

If the status attribute is set to error then only error messages will be
written to the console. This makes troubleshooting configuration errors
possible. As an example, if the configuration above is changed to have
the status set to error and the logger declaration is:

[source,xml]
----
<logger name="EventLogger" level="info" additivity="false">
  <AppenderRef ref="Routng"/>
</logger>
----

the following error message will be produced.

....
2011-11-24 23:21:25,517 ERROR Unable to locate appender Routng for logger EventLogger
....

Applications may wish to direct the status output to some other
destination. This can be accomplished by setting the dest attribute to
either "err" to send the output to stderr or to a file location or URL.
This can also be done by insuring the configured status is set to OFF
and then configuring the application programmatically such as:

[source,java]
----
StatusConsoleListener listener = new StatusConsoleListener(Level.ERROR);
StatusLogger.getLogger().registerListener(listener);
----



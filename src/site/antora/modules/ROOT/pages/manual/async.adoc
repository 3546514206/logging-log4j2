////
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
////
= Asynchronous logging
Remko Popma <rpopma@apache.org>; Piotr Karwasz <pkarwasz@apache.org>

Asynchronous logging is a technique to improve application logging performance by executing all I/O operations in a separate thread.

Log4j offers out-of-the-box two different asynchronous logging solutions:

Asynchronous appender::
+
A classical queue-based asynchronous appender, which is available since Log4j 1.
+
Since Log4j 2 the type of queue is configurable to allow users to use faster and more performant queues, such as those from the
https://github.com/JCTools/JCTools?tab=readme-ov-file#jctools[JCTools]
or
https://github.com/conversant/disruptor[Conversant Disruptor] projects.
+
See xref:manual/appenders.adoc#AsyncAppender[Asynchronous appender] for more details.

Asynchronous loggers::
+
A new logger implementation based on
https://lmax-exchange.github.io/disruptor/[LMAX Disruptor]
that provides even better latency and throughput.
+
See <<asynchronous-loggers>> for more details.

[CAUTION]
====
Logging performance depends greatly on the architecture of your application and the way you use logging.

The solutions offered by this chapter should be evaluated using benchmarks against your own application.

If benchmarks and profiling don't show a statistically significant difference between asynchronous and synchronous logging solutions, the latter one is recommended, since it is the simplest one.
====

Although asynchronous logging can give significant performance benefits, there are situations where you may want to choose synchronous logging.

[[Trade-offs]]
[[trade-offs]]
The trade-offs of asynchronous logging are:

Benefits::

Higher peak throughput:::
+
Applications that occasionally need to log bursts of messages, can take advantage of this.
+
Asynchronous logging can prevent or dampen latency spikes by shortening the wait time until the next message can be logged.
+
If the queue size is large enough to handle the burst, asynchronous logging will prevent your application from falling behind during a sudden increase of activity.

Lower logging latency:::
+
link:../javadoc/log4j-api/org/apache/logging/log4j/Logger.html[Logger]
method calls return faster, since most of the work is done on the I/O thread.

Drawbacks::

Lower sustainable throughput:::
+
If the _sustained rate_ at which your application is logging messages is faster than the maximum sustained throughput of the underlying appender, the queue will fill up and the application will end up logging at the speed of the slowest appender.
+
If this happens, consider selecting a xref:manual/performance.adoc#whichAppender[faster appender], or logging less.
If neither of these is an option, you may get better throughput and fewer latency spikes by logging synchronously.

Error handling:::
+
If a problem happens during the logging process and an exception is thrown, it is less easy for an asynchronous logger or appender to signal this problem to the application.
+
This can partly be alleviated by configuring an
<<exception-handler>>, but this may still not cover all cases.
+
[CAUTION]
====
If logging is part of your business logic, e.g. you are using Log4j as an audit logging framework, we would recommend to synchronously log those audit messages.

See <<MixedSync-Async>> on how to log some messages synchronously.
====

Mutable messages:::
+
Most
link:../javadoc/log4j-api/org/apache/logging/log4j/message/Message.html[Message]
implementations take a snapshot of the formatted message on the calling thread (cf.
xref:manual/systemproperties.adoc#log4j2.formatMsgAsync[log4j2.formatMsgAsync]).
The log message will not change even if the arguments of the logging call are modified later.
+
There are some exceptions to this rule.
link:../javadoc/log4j-api/org/apache/logging/log4j/message/MapMessage.html[MapMessage]
and
link:../javadoc/log4j-api/org/apache/logging/log4j/message/StructuredDataMessage.html[StructuredDataMessage]
are mutable by design: fields can be added to these messages after the message object was created.
These messages should not be modified after they are logged with asynchronous loggers or asynchronous appenders.
+
Custom
link:../javadoc/log4j-api/org/apache/logging/log4j/message/Message.html[Message]
implementations should be designed with asynchronous use in mind, and either take a snapshot of their parameters at construction time, or document their thread-safety characteristics (cf.
link:../javadoc/log4j-api/org/apache/logging/log4j/message/AsynchronouslyFormattable.html[AsynchronouslyFormattable]).

CPU consumption:::
If your application is running in an environment where CPU resources are scarce, like a VM with a single vCPU, starting another thread is not likely to give better performance.


[id=asynchronous-loggers]
== Asynchronous loggers

Log4j 2 makes a number of improvements in the area of asynchronous logging:

* It introduces *asynchronous loggers*, whose aim is to return from the logging call to the application as soon as possible.
+
Asynchronous loggers are based on link:#UnderTheHood[LMAX Disruptor], a lock-free inter-thread communication library, instead of queues, resulting in higher throughput and lower latency.
+
You can choose between:

** <<AllAsync>>, which gives a better performance,
** <<MixedSync-Async>>, which gives more flexibility.

* *Asynchronous appenders* have been enhanced to flush to the OS at the end of a batch, when the queue becomes empty.
+
This produces the same result as the xref:manual/appenders.adoc#immediateFlush[immediateFlush] attribute of many appenders: it guarantees that the batch of log events is passed to the OS, but does not guarantee that the OS forwards the data to the appropriate physical device.

[#installation]
== Installation

In order to use async loggers, you need to add LMAX Disruptor to you application's dependencies, by adding the following dependency to your build tool:

[tabs]
====
Maven::
+
[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>com.lmax</groupId>
  <artifactId>disruptor</artifactId>
  <version>{disruptor-version}</version>
  <scope>runtime</scope>
</dependency>
----

Gradle::
+
[source,groovy,subs="+attributes"]
----
runtimeOnly 'com.lmax:disruptor:{disruptor-version}'
----
====

[#AllAsync]
== Making all loggers asynchronous

This is simplest to configure and gives the best performance.

To make all logger asynchronous, you need to set the
xref:manual/systemproperties.adoc#log4j2.contextSelector[log4j2.contextSelector]
property to one of the asynchronous logger context selectors:

link:../javadoc/log4j-core/org/apache/logging/log4j/core/async/BasicAsyncLoggerContextSelector[org.apache.logging.log4j.core.async.BasicAsyncLoggerContextSelector]::
This will create a single logger context and disruptor for all the classes in the JVM,

link:../javadoc/log4j-core/org/apache/logging/log4j/core/async/AsyncLoggerContextSelector[org.apache.logging.log4j.core.async.AsyncLoggerContextSelector]::
This will create a different logger context and disruptor for each classloader in the JVM.

[IMPORTANT]
====
When using an asynchronous logger context you should use only `Root` and `Logger` elements (cf.
xref:manual/configuration.adoc#configuring-loggers[Logger configuration]).

If you use `AsyncRoot` and `AsyncLogger` configuration elements, two asynchronous barriers will be created instead of one, which will impair performance.
====

[[SysPropsAllAsync]]
=== Configuration Properties

Since the disruptor is created at the same time as the logger context and before any Log4j configuration file is loaded, tuning async loggers is only possible through configuration properties.

The following elements are configurable:

* the generic behavior of asynchronous components, such as the queue full policy and message formatting.
+
See xref:manual/systemproperties.adoc#properties-async[Commons async configuration] for more details.

* the parameters of the disruptor, such as the size of the ring buffer and the wait strategy to use.
+
See xref:manual/systemproperties.adoc#properties-async-logger[Full asynchronous logger configuration] for more details.

[TIP]
====
You can place the selected value of the
xref:manual/systemproperties.adoc#log4j2.contextSelector[log4j2.contextSelector] and other configuration properties in a `log4j2.component.properties` file at the root of your application's classpath.

See xref:manual/systemproperties.adoc#property-sources[Property Sources] for more details.
====

[#MixedSync-Async]
== Mixing synchronous and asynchronous loggers

Synchronous and asynchronous loggers can be combined in a single configuration.
This gives you more flexibility at the cost of a slight loss in performance (compared to making all loggers asynchronous).

In order to use this configuration, you need to keep the
xref:manual/systemproperties.adoc#log4j2.contextSelector[log4j2.contextSelector] at its default value and use one of the
`AsyncRoot` and `AsyncLogger` configuration elements to designate the loggers that you want to be asynchronous.

A configuration that mixes asynchronous loggers might look like:

[tabs]
====
XML::
+
[source,xml]
----
include::example$manual/configuration/mixed-async.xml[lines=1;18..-1]
----

JSON::
+
[source,json]
----
include::example$manual/configuration/mixed-async.json[]
----

YAML::
+
[source,yaml]
----
include::example$manual/configuration/mixed-async.yaml[lines=17..-1]
----

Java properties::
+
[source,properties]
----
include::example$manual/configuration/mixed-async.properties[lines=17..-1]
----
====

<1> All the appenders referenced by `Root` and `Logger` are called synchronously.
This is especially important for audit logging, since exceptions can be forwarded to the caller.
<2> All the appenders references by `AsyncRoot` and `AsyncLogger` are called asynchronously.
These log statements will cause a smaller latency for the caller.

[[SysPropsMixedSync-Async]]
=== Configuration Properties

Since all `AsyncRoot` and `AsyncLogger` components share the same disruptor, its configuration is available through configuration properties.

The following elements are configurable:

* the generic behavior of asynchronous components, such as the queue full policy and message formatting.
+
See xref:manual/systemproperties.adoc#properties-async[Commons async configuration] for more details.

* the parameters of the disruptor, such as the size of the ring buffer and the wait strategy to use.
+
See xref:manual/systemproperties.adoc#properties-async-logger-config[Mixed asynchronous logger configuration] for more details.

[TIP]
====
You can place the values of configuration properties in a `log4j2.component.properties` file at the root of your application's classpath.

See xref:manual/systemproperties.adoc#property-sources[Property Sources] for more details.
====

[#custom-waitstrategy]
== Custom `WaitStrategy`

The system properties mentioned in the section above allow only to choose from among a fixed set of wait strategies.

In order to use a custom wait strategy you need to:

. Use the <<MixedSync-Async,mixed sync/async configuration method>> above,
. Implement the interface
link:../javadoc/log4j-core/org/apache/logging/log4j/core/async/AsyncWaitStrategyFactory.html[AsyncWaitStrategyFactory]; the implementation must have a public no-arg constructor,
. Add an xref:plugin-reference.adoc#org-apache-logging-log4j_log4j-core_org-apache-logging-log4j-core-async-AsyncWaitStrategyFactoryConfig[AsyncWaitStrategyFactory Log4j plugin]
to your configuration.

[tabs]
====
XML::
+
[source,xml]
----
include::example$manual/configuration/custom-wait-strategy.xml[lines=1;18..-1]
----

JSON::
+
[source,json]
----
include::example$manual/configuration/custom-wait-strategy.json[]
----

YAML::
+
[source,yaml]
----
include::example$manual/configuration/custom-wait-strategy.yaml[lines=17..-1]
----

Java properties::
+
[source,properties]
----
include::example$manual/configuration/custom-wait-strategy.properties[lines=17..-1]
----
====

[#Location]
== Location

Computing the location of a log event is an expensive operation.
Synchronous appenders are around 1.5&nbsp;&ndash;&nbsp;5 times slower, when location information is required.
The impact on asynchronous loggers and appenders is even higher, since the component must decide whether to compute it or not **before** crossing the asynchronous barrier.
For asynchronous loggers logging with location is 30&nbsp;&ndash;&nbsp;100 times slower than without location.

See also xref:manual/layouts.adoc#location-information[Location information].

[WARNING]
====
Location information is disabled by default for async loggers and async appenders.

In order to enable it for a certain logger, set its
xref:manual/configuration.adoc#logger-attributes-includeLocation[includeLocation] attribute to `true`.
====

[id=exception-handler]
== Exception handler

In order to handle exceptions that occur on the asynchronous thread, you can configure a custom
https://lmax-exchange.github.io/disruptor/javadoc/com.lmax.disruptor/com/lmax/disruptor/ExceptionHandler.html[ExceptionHandler<T>].

The exact type of handler depends on the configuration mode:

Full asynchronous::
+
If all the loggers are asynchronous you need to:
+
* implement an
link:../javadoc/log4j-core/org/apache/logging/log4j/core/async/RingBufferLogEvent.html[ExceptionHandler<? super RingBufferLogEvent>]
* set its fully qualified class name as value of the
xref:manual/systemproperties.adoc#log4j2.asyncLoggerExceptionHandler[log4j2.asyncLoggerExceptionHandler]
configuration property.

Mixed synchronous/asynchronous::
+
If you use a mix of sync and async loggers you need to:
+
* implement a
link:../javadoc/log4j-core/org/apache/logging/log4j/core/async/AsyncLoggerConfigDisruptor.Log4jEventWrapper.html[ExceptionHandler<? super AsyncLoggerConfigDisruptor.Log4jEventWrapper>]
* set its fully qualified class name as value of the
xref:manual/systemproperties.adoc#log4j2.asyncLoggerConfigExceptionHandler[log4j2.asyncLoggerConfigExceptionHandler]
configuration property.

[#UnderTheHood]
== Under The Hood

Asynchronous Loggers are implemented using the
https://lmax-exchange.github.io/disruptor/[LMAX Disruptor] inter-thread messaging library.
From the LMAX web site:

____
...using queues to pass data between stages of the system was
introducing latency, so we focused on optimising this area.
The Disruptor is the result of our research and testing.
We found that cache misses at the CPU-level, and locks requiring kernel arbitration are both extremely costly, so we created a framework which has "mechanical sympathy" for the hardware it's running on, and that's lock-free.
____

LMAX Disruptor internal performance comparisons with the Java SE
https://docs.oracle.com/javase/{java-target-version}/docs/api/java/util/concurrent/ArrayBlockingQueue.html[ArrayBlockingQueue]
class can be found on
https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results[LMAX Disruptor Wiki].
